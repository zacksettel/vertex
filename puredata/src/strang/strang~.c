//	Modalys force connection + string//		November 1997 dudas hack//		Based on the c++ Modalys implementation by Joseph Morrison		//		for Per Martensson's cursus piece shoved it into one object//      optimised Nov 98 to agree with NVM modifications#include "m_pd.h"#include "math.h"#include "strang.h"#ifdef NT#pragma warning( disable : 4244 )#pragma warning( disable : 4305 )#endif#define N_PI 3.14159265358979323846#define N_TWOPI 6.28318530717958647692#define N_SPERIOD 2.26757369614512e-05#define N_SRATE 44100.// #define RES_ID 16004static t_class *strang_class;typedef struct _strang{	t_object x_obj;   t_float x_dummy;  // needed by some stupid DSP macro	double s_SampleRate;	double s_SamplePeriod;		int s_n;			// number of modes allocated	// from string	double s_lg;		// length	double s_te;		// tension	double s_de;		// density	double s_rad;		// radius	double s_me;		// young's modulus	double s_pf;		// freq loss	double s_pc;		// const loss	double *s_zero;		// these two are for intermediary calculations	double *s_temp;	double *s_freq;		// modal frequency data	double *s_loss;		// modal loss data	double *s_modes;	double **s_modal;	// modeshape data (modes * points)	***EXPORT TO ACCESS***	int s_numModes;		//	.	.	.	.	.	.	.	.	***EXPORT TO BOTH!***	int s_numPoints;	//	.	.	.	.	.	.	.	.	***EXPORT TO ACCESS***	double *s_om;		// initobject things	double *s_xi;	double *s_impInv;	//	.	.	.	.	.	.	.	.	***EXPORT TO ACCESS***	double *s_impInvSr;	//	.	.	.	.	.	.	.	.	***EXPORT TO FORCE CTL***	double *s_omSqImpInv;//	.	.	.	.	.	.	.	.	***EXPORT TO FORCE CTL***		double s_norm;		// normalization	double s_normSqrt;	//	.	.	.	.	.	.	.	.	***EXPORT TO FORCE CTL***		// from access	double s_inloc; // store positions in	double s_outloc;		double *s_inPosition; // decoded access	double *s_inLocation;  // points-to-modes controller = access modal location	double *s_inImpInvLocation; // export to FORCE or other connection		double *s_outPosition; // decoded access	double *s_outLocation;	double *s_outImpInvLocation; // export to force or other connection		// from force object	double *s_driveModalSpeedComp; // force in speed component	double *s_modalModalSpeedComp; // other components in initobject	double *s_allModalSpeedComp;	double *s_modalPosition;		//void *x_outlet2;	void *x_outlet;} t_strang;void strang_makestring(t_strang *x);void strang_initobject(t_strang *x);void strang_setargs(t_strang *x, int ac, t_atom *av);void strang_set(t_strang *x, t_symbol *s, int ac, t_atom *av);void strang_ft1(t_strang *x, double f);void strang_ft2(t_strang *x, double f);void strang_ftin(t_strang *x, double f);void strang_ftout(t_strang *x, double f);void strang_makeaccesses(t_strang *x);void strang_initmotion(t_strang *x);void strang_clear(t_strang *x, t_symbol *s, int ac, t_atom *av);void strang_free(t_strang *x);void strang_alloc(t_strang *x);void *strang_new(t_float n);t_int *strang_perform(t_int *w);t_int *strang_bidon(t_int *w);static void strang_dsp(t_strang *x, t_signal **sp);void strang_makestring(t_strang *x){	int n = x->s_n;	double lg = x->s_lg;	double te = x->s_te;	double de = x->s_de;	double rad = x->s_rad;	double me = x->s_me;	double pf = x->s_pf;	double pc = x->s_pc;		double se = N_PI * rad * rad;	double rg = rad / 2.0;		double sPeriod = x->s_SamplePeriod;		double beta;	// = sqrt(te/(8.0*pow(M_PI*rg,2.0)*me*se));	double a;		// = 2.0*beta*beta;        	double b;		// = me*rg*rg/de;		double *zer;	double *nor;	double *fre;	double *abs;	double **mod;	int nbmodes, nbpoints;	int i,j;		for(i=0; i<n; i++) x->s_zero[i] = 0.;	for(i=0; i<n; i++) x->s_freq[i] = 0.;		for(i=0; i<n; i++) x->s_loss[i] = 0.;	for(i=0; i<n; i++) {		for(j=0; j<n; j++) x->s_modal[i][j] = 0.;	// NMODES used for NPOINTS!!    }		zer = x->s_zero;	nor = x->s_temp;	fre = x->s_freq;	abs = x->s_loss;	mod = x->s_modal;		beta = sqrt(te/(8.0*pow(N_PI*rg,2.0)*me*se));	a = 2.0*beta*beta;        	b = me*rg*rg/de;		cde_zero_cherche  (zer, lg, beta, n);	n = cde_reduit_nm (n, zer, a, b, sPeriod);		cde_mat_mod_calc(n, beta, lg, se, de, zer, mod, nor);		string_freq_loss_calc(n, zer, fre, abs, a, b, pc, pf);	nbmodes = n;	nbpoints = n;		x->s_numModes = n;	x->s_numPoints = n;		outlet_float(x->x_outlet, x->s_freq[0]); // fund freq out right}void strang_initobject(t_strang *x){	int i, j;	double fr, lo, om, xi, oms, ii, iisr, osii, mo, norm;	double sr = x->s_SampleRate;	double sp = x->s_SamplePeriod;		int nModes = x->s_numModes;	int nPoints = x->s_numPoints;		norm = 0.0;		for (i=0; i < nModes; i++) {		fr = x->s_freq[i];		lo = x->s_loss[i];				if (fr >= (sr / 2.0))			error ("mode %d exceeds nyquist!",i);				// compute om and xi		om = 2.0 * sin (sp * N_PI * fr) / sp;		xi = (lo * N_PI * 2) - (om * om * sp);		oms = om * om; // om squared				// compute impInv (1 / impedance) & others		ii = 1.0 / (xi + (oms * sp) + (1.0 / sp));		iisr = ii * sr;		osii = oms * ii;					x->s_om[i] = om;		x->s_xi[i] = xi;		x->s_impInv[i] = ii;			x->s_impInvSr[i] = iisr;		x->s_omSqImpInv[i] = osii;			// compute normalization		for (j=0; j < nPoints; j++ ) {			mo = x->s_modal[i][j];			norm += mo * mo; 		}	}	norm *= nModes / (double) nPoints;		x->s_norm = norm;	x->s_normSqrt = sqrt(norm);    }/*void strang_initobject(t_strang *x){	int i, j;	double norm;	int numModes = x->s_numModes;	int numPoints = x->s_numPoints;		// compute om and xi -------------		for (i=0; i < numModes; i++) {		if (x->s_freq[i] >= (SampleRate / 2.0))			error ("mode %d exceeds nyquist!",i);		x->s_om[i] = 2.0 * sin (SamplePeriod * M_PI * x->s_freq[i]) / SamplePeriod;	}	for (i=0; i < numModes; i++) {		x->s_xi[i] = (x->s_loss[i] * M_PI * 2) - (x->s_om[i] * x->s_om[i] * SamplePeriod);	}		// compute impInv	---------------	// called "impInv" because it's actually 1.0 / impedance	for (i=0; i < numModes; i++) {                            		x->s_impInv[i] = 1.0 / (x->s_xi[i] + (x->s_om[i] * x->s_om[i] * SamplePeriod)      								+ (1.0 / SamplePeriod));	}	for (i=0; i < numModes; i++) {		x->s_impInvSr[i] = x->s_impInv[i] * SampleRate;		x->s_omSqImpInv[i] = x->s_om[i] * x->s_om[i] * x->s_impInv[i];	}	norm = 0.0; 	for (i=0; i < numModes; i++) {		for (j=0; j < numPoints; j++ ) {			norm += x->s_modal[i][j] * x->s_modal[i][j]; 		}	}	norm *= numModes / (double) numPoints;		x->s_norm = norm;	x->s_normSqrt =sqrt(norm);    }*/void strang_setargs(t_strang *x, int ac, t_atom *av){	if (ac>0 && av[0].a_type == A_FLOAT && av[0].a_w.w_float > 0.) //length		x->s_lg = (double) av[0].a_w.w_float;	// else if (ac>0 && av[0].a_type == A_LONG && av[0].a_w.w_long > 0)		// x->s_lg = (double)av[0].a_w.w_long;		if (ac>1 && av[1].a_type == A_FLOAT && av[1].a_w.w_float > 0.) //tension		x->s_te = (double) av[1].a_w.w_float;	//else if (ac>1 && av[1].a_type == A_LONG && av[1].a_w.w_long > 0)	//	x->s_te = (double)av[1].a_w.w_long;	if (ac>2 && av[2].a_type == A_FLOAT && av[2].a_w.w_float > 0.) //density		x->s_de = (double) av[2].a_w.w_float;	//else if (ac>2 && av[2].a_type == A_LONG && av[2].a_w.w_long > 0)	//	x->s_de = (double)av[2].a_w.w_long;			if (ac>3 && av[3].a_type == A_FLOAT && av[3].a_w.w_float > 0.) //radius		x->s_rad = (double) av[3].a_w.w_float;	//else if (ac>3 && av[3].a_type == A_LONG && av[3].a_w.w_long > 0)	//	x->s_rad = (double)av[3].a_w.w_long;/*	if (ac>5 && av[4].a_type == A_FLOAT && av[5].a_type == A_LONG && av[4].a_w.w_float > 0.) //young		x->s_me = av[4].a_w.w_float * pow(10,av[5].a_w.w_long);		else if (ac>5 && av[4].a_type == A_LONG && av[5].a_type == A_LONG && av[4].a_w.w_long > 0)		x->s_me = (double)av[4].a_w.w_long * pow(10,av[5].a_w.w_long);*/	if (ac>5 && av[4].a_type == A_FLOAT && av[5].a_type == A_FLOAT && av[4].a_w.w_float > 0.) //young		x->s_me = (double) av[4].a_w.w_float * pow(10,av[5].a_w.w_float);		//else if (ac>5 && av[4].a_type == A_FLOAT && av[5].a_type == A_FLOAT && av[4].a_w.w_float > 0)	//	x->s_me = (double)av[4].a_w.w_float * pow(10,av[5].a_w.w_float);	if (ac>6 && av[6].a_type == A_FLOAT) //freq loss		x->s_pf = (double) av[6].a_w.w_float;	//else if (ac>6 && av[6].a_type == A_LONG)	//	x->s_pf = (double)av[6].a_w.w_long;			if (ac>7 && av[7].a_type == A_FLOAT) //const loss		x->s_pc = (double) av[7].a_w.w_float;	//else if (ac>7 && av[7].a_type == A_LONG)	//	x->s_pc = (double)av[7].a_w.w_long;	}void strang_set(t_strang *x, t_symbol *s, int ac, t_atom *av){	if (ac) {		strang_setargs(x, ac, av);		strang_makestring(x);		strang_initobject(x);		strang_makeaccesses(x);	}}/*  ======================================================================= */void strang_ft1(t_strang *x, double f){	strang_ftin(x,f);	strang_makeaccesses(x);	//post("inlet 1",0);}void strang_ft2(t_strang *x, double f){	strang_ftout(x,f);	strang_makeaccesses(x);	//post("inlet 2",0);}void strang_ftin(t_strang *x, double f){	int np, i;		np = x->s_numPoints;	f *= (np - 1);		for (i=0; i< np; i++) {		if (i == floor(f)) x->s_inPosition[i] = 1. - (f - floor(f));		else if (i == floor(f) + 1) x->s_inPosition[i] = 1. - (floor(f) + 1. - f);		else x->s_inPosition[i] = 0.;	}}void strang_ftout(t_strang *x, double f){	int np, i;		np = x->s_numPoints;	f *= (np - 1);	for (i=0; i< np; i++) {		if (i == floor(f)) x->s_outPosition[i] = 1. - (f - floor(f));		else if (i == floor(f) + 1) x->s_outPosition[i] = 1. - (floor(f) + 1. - f);		else x->s_outPosition[i] = 0.;	}}void strang_makeaccesses(t_strang *x){	int i, j;	//int inloc, outloc;	int nm, np;	nm = x->s_numModes;	np = x->s_numPoints;	for (i=0; i< nm; i++) {		x->s_inLocation[i] = 0.;		x->s_outLocation[i] = 0.;	}	// matrix multiplication	for (i=0; i< nm; i++) {		for (j=0; j< np; j++) {			if (x->s_inPosition[j] != 0.)				x->s_inLocation[i] += x->s_inPosition[j] * x->s_modal[i][j];			if (x->s_outPosition[j] != 0.)				x->s_outLocation[i] += x->s_outPosition[j] * x->s_modal[i][j];		}		x->s_inImpInvLocation[i] = x->s_inLocation[i] * x->s_impInv[i];		x->s_outImpInvLocation[i] = x->s_outLocation[i] * x->s_impInv[i];		}}/*  ======================================================================= */void strang_initmotion(t_strang *x){	int i;	int numModes = x->s_numModes;		// initialize the speed components to 0.0 (no initial movement)	for (i=0; i < numModes; i++) {		x->s_driveModalSpeedComp[i] = 0.0;		x->s_modalModalSpeedComp[i] = 0.0;		x->s_allModalSpeedComp[i] = 0.0;		x->s_modalPosition[i] = 0.0;	} }void strang_clear(t_strang *x, t_symbol *s, int ac, t_atom *av){	strang_initmotion(x);}// ---------------------------------------------------------------------------------void strang_free(t_strang *x){	t_freebytes(x->s_zero,(size_t)(x->s_n*sizeof(double)));	t_freebytes(x->s_temp,(size_t)(x->s_n*sizeof(double)));	t_freebytes(x->s_freq,(size_t)(x->s_n*sizeof(double)));	t_freebytes(x->s_loss,(size_t)(x->s_n*sizeof(double)));	t_freebytes(x->s_modes,(size_t)(x->s_n*x->s_n*sizeof(double)));	t_freebytes(x->s_modal,(size_t)(x->s_n*sizeof(double *)));		t_freebytes(x->s_om,(size_t)(x->s_n*sizeof(double *)));	t_freebytes(x->s_xi,(size_t)(x->s_n*sizeof(double *)));	t_freebytes(x->s_impInv,(size_t)(x->s_n*sizeof(double *)));	t_freebytes(x->s_impInvSr,(size_t)(x->s_n*sizeof(double *)));	t_freebytes(x->s_omSqImpInv,(size_t)(x->s_n*sizeof(double *)));		t_freebytes(x->s_inPosition,(size_t)(x->s_n*sizeof(double *)));	t_freebytes(x->s_inLocation,(size_t)(x->s_n*sizeof(double *)));	t_freebytes(x->s_inImpInvLocation,(size_t)(x->s_n*sizeof(double *)));	t_freebytes(x->s_outPosition,(size_t)(x->s_n*sizeof(double *)));	t_freebytes(x->s_outLocation,(size_t)(x->s_n*sizeof(double *)));	t_freebytes(x->s_outImpInvLocation,(size_t)(x->s_n*sizeof(double *)));		t_freebytes(x->s_driveModalSpeedComp,(size_t)(x->s_n*sizeof(double *)));	t_freebytes(x->s_modalModalSpeedComp,(size_t)(x->s_n*sizeof(double *)));	t_freebytes(x->s_allModalSpeedComp,(size_t)(x->s_n*sizeof(double *)));	t_freebytes(x->s_modalPosition,(size_t)(x->s_n*sizeof(double *)));		//dsp_free((t_object *)x);}void strang_alloc(t_strang *x){	int i;    // string data	x->s_zero = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	x->s_temp = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	x->s_freq = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	x->s_loss = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	x->s_modes = (double *)t_getbytes((size_t)(x->s_n*x->s_n*sizeof(double)));	x->s_modal = (double **)t_getbytes((size_t)(x->s_n*sizeof(double *)));    	for(i=0;i<x->s_n;i++) {		x->s_modal[i] = &x->s_modes[i*x->s_n];		}		// initobject things	x->s_om = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	x->s_xi = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	x->s_impInv = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	x->s_impInvSr = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	x->s_omSqImpInv = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));			x->s_inPosition = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	x->s_inLocation = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	x->s_inImpInvLocation = (double *)t_getbytes((size_t)(x->s_n*sizeof(double))); 	x->s_outPosition = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	x->s_outLocation = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	x->s_outImpInvLocation = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	// updated every sample!!!	x->s_driveModalSpeedComp = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	x->s_modalModalSpeedComp = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	x->s_allModalSpeedComp = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));	x->s_modalPosition = (double *)t_getbytes((size_t)(x->s_n*sizeof(double)));		}void *strang_new(t_float n){	int i,j;    t_strang *x = (t_strang *)pd_new(strang_class);    outlet_new(&x->x_obj, gensym("signal"));    inlet_new(&x->x_obj, &x->x_obj.ob_pd, gensym("float"), gensym("ft1"));    inlet_new(&x->x_obj, &x->x_obj.ob_pd, gensym("float"), gensym("ft2"));	//	t_strang *x = (t_strang *)newobject(strang_class);		//floatin((t_object *)x,2);	//floatin((t_object *)x,1);	//dsp_setup((t_object *)x,1);	x->x_outlet = outlet_new(&x->x_obj, gensym("float"));//	x->x_outlet = floatout(x);//	outlet_new((t_object *)x, "signal");		x->s_SampleRate =  N_SRATE; // these will chqnge in dsp()	x->s_SamplePeriod = N_SPERIOD;		if (n>0)		x->s_n = (int)n;		else		x->s_n = 8;		// just to be sure	x->s_numModes = x->s_n;		// default string parameters	x->s_lg = 1.0;	x->s_te = 100.0;	x->s_de = 1000.0;	x->s_rad = 0.001;	x->s_me = 1e9;	x->s_pf = 1.0;	x->s_pc = 1.0;    x->s_inloc = 0.3;    x->s_outloc = 0.6;    	strang_alloc(x);	strang_makestring(x);	strang_initobject(x);       	strang_ftin(x, x->s_inloc);	strang_ftout(x, x->s_outloc);	strang_makeaccesses(x);	strang_initmotion(x);    return (x);}// ---------------------------------------------------------------------------------t_int *strang_perform(t_int *w)		// our dsp calculation{	t_float *in = (t_float *)(w[1]);	t_float *out = (t_float *)(w[2]);	t_strang *x = (t_strang *)(w[3]);	int n = (int)(w[4]);			// vector size 		int i;	double sp, ii, po, oi;	double dr, il, ol, mo;	double tin, tout;		double *xdMSC;// = x->s_driveModalSpeedComp[0];	double *xiIIL;// = x->s_inImpInvLocation[0];	//double *xoIIL;// = x->s_outImpInvLocation[0];	//double *xiLOC;// = x->s_inLocation[0];	double *xoLOC;// = x->s_outLocation[0];	double *xaMSC;// = x->s_allModalSpeedComp[0];	double *xmMSC;// = x->s_modalModalSpeedComp[0];	double *xiISr;// = x->s_impInvSr[0];	double *xmPos;// = x->s_modalPosition[0];	double *xoSII;// = x->s_omSqImpInv[0];		double *dMSC;	double *iIIL;	//double *oIIL;	//double *iLOC;	double *oLOC;	double *aMSC;	double *mMSC;	double *iISr;	double *mPos;	double *oSII;			double sPd = x->s_SamplePeriod;//	double nSqrt = x->s_normSqrt;  zkFix 05.2005	double invnSqrt = 1/x->s_normSqrt;	int numModes = x->s_numModes;	int nMod;										//	if (x->x_obj.z_disabled)	//	goto out;		xdMSC = &x->s_driveModalSpeedComp[-1];	xiIIL = &x->s_inImpInvLocation[-1];	//xoIIL = &x->s_outImpInvLocation[-1];	//xiLOC = &x->s_inLocation[-1];	xoLOC = &x->s_outLocation[-1];	xaMSC = &x->s_allModalSpeedComp[-1];	xmMSC = &x->s_modalModalSpeedComp[-1];	xiISr = &x->s_impInvSr[-1];	xmPos = &x->s_modalPosition[-1];	xoSII = &x->s_omSqImpInv[-1];			numModes = x->s_numModes+1;				while (--n) {    			tin = (double)  *++in;		tout = 0.0;				dMSC = xdMSC;		iIIL = xiIIL;		//oIIL = xoIIL;		//iLOC = xiLOC;		oLOC = xoLOC;		aMSC = xaMSC;		mMSC = xmMSC;		iISr = xiISr;		mPos = xmPos;		oSII = xoSII;    	 	    	nMod = numModes;    			while (--nMod) {						il = *++iIIL;			ol = *++oLOC; // output location, not invImpLocation			sp = *++aMSC; 			ii = *++iISr;			po = *++mPos; 			oi = *++oSII;						dr = tin * il;			mo = (sp * ii) - (po * oi);			sp = dr + mo; // + IE when connection strang present			po += sPd * sp;			tout += sp * ol;						*++dMSC = dr;			*++mMSC = mo;			*aMSC = sp;			*mPos = po;		}		//tout /= nSqrt;	zkFix 05.2005		tout *= invnSqrt;				*++out = (t_float)tout;	}out:	return (w+5);					// return pointer to NEXT object in dsp chain}t_int *strang_bidon(t_int *w)		// outputs -0.000001 if there's a problem{	t_float *in = (t_float *)(w[1]);	t_float *out = (t_float *)(w[2]);	t_strang *x = (t_strang *)(w[3]);	int n = (int)(w[4]);//	if (x->x_obj.z_disabled)//		goto out;			while (--n) *out++ = -0.000001;out:	return (w+5);}	// the dsp method that calls the above routines:static void strang_dsp(t_strang *x, t_signal **sp)  {		x->s_SampleRate =  (double) sys_getsr(); 	x->s_SamplePeriod = 1.0/ x->s_SampleRate;		//if (count[0])	// if inlet 0 is connected		dsp_add(strang_perform, 4, sp[0]->s_vec-1, sp[1]->s_vec-1, x, sp[0]->s_n+1);	//if (count[0])	// if inlet 0 is connected	//	dsp_add(strang_perform, 4, sp[0]->s_vec-1, sp[1]->s_vec-1, x, sp[0]->s_n+1);	//else								// otherwise, if there's a problem:	//	dsp_add(strang_bidon, 4, sp[0]->s_vec-1, sp[1]->s_vec-1, x, sp[0]->s_n+1);}void strang_tilde_setup(void){   strang_class = class_new(gensym("strang~"), (t_newmethod)strang_new, (t_method)strang_free,    	sizeof(t_strang), 0, A_DEFFLOAT, 0);      CLASS_MAINSIGNALIN(strang_class, t_strang, x_dummy);  // setup(&strang_class, strang_new, (method)strang_free, (short)sizeof(t_strang), 0L, A_DEFLONG, 0);    // addmess((method)strang_dsp, "dsp", A_CANT, 0);	// dsp method    class_addmethod(strang_class, (t_method)strang_dsp, gensym("dsp"), 0);    class_addmethod(strang_class, (t_method)strang_clear, gensym("clear"), A_GIMME, 0);    // addmess((method)strang_clear, "clear", A_GIMME, 0);        class_addmethod(strang_class, (t_method)strang_set, gensym("set"), A_GIMME, 0);   // addmess((method)strang_set, "set", A_GIMME, 0);        class_addmethod(strang_class, (t_method)strang_ft1, gensym("ft1"), A_FLOAT, 0);   // addftx((method)strang_ft1, 1);    class_addmethod(strang_class, (t_method)strang_ft2, gensym("ft2"), A_FLOAT, 0);    // addftx((method)strang_ft2, 2);        // dsp_initclass();							// must init the dsp        post (" ",0);    post("================================================",0);    post("strang~ object version 0.1",0);    post("     a Modlays mono-string with force connection",0);    post("     dudas hack 1997-1998, for Per Martensson",0);    post("================================================",0);    post(" ",0);    }//____________________________________________________  From  strang_ana.c/*======================================================================NVM string functions - dudas hack 1997-1998Modified from Jean-Marie Adrien and Joseph Morrison, 1991.    extracted from modal_analysis.cc modified in c for msp by dudasHistory:October 1998:optimised the pitch adjustment things and made them workSeptember 1998:mixed the freq and loss together in same function    string_freq_loss_cal()shoved prototypes at top of file.    Spring-Summer 1998:    modified and optimized some of the functions with loopsNovember 1997:cde_mat_mod_cal has added buffer (double *)nor 	which used to be allocated with DoubleVector*/// Functions used for the modal analyses of strings.  These really// should be rewritten (they are unreadable now) but it's a low// priority item, as they are used only in the constructor functions// for the BiString and MonoString classes (i.e. they have nothing to// do with the dynamic synthesis).//    - Joe Morrison, February 20, 1991.// This bissection code is really a kludge.// Zeros Impairs : on part de (n+1)/l et on divise par deux VERS// L'ARRIERE l'intervalle separant de x0 courant de l'asymptote en// (2(n+1)-1)/2l. Tant que l'on n'a pas incremente n, on reduit// l'intervalle x0-x1. Il se peut que l'on soit deja, au moment ou// l'on trouve le zero, avec un intervalle x0-x1 inferieur au seuil,// c'est pourquoi on initialise x2 avant la boucle de bissection.void cde_zero_cherche(double *zero, double l, double b, int nm){    double x0,fx0,x1,fx1,fx2;    double box0, box1, box2;    double x2 = 0;   // Shut G++ -Wall up about possible uninitialized use    double piLen,twoBSq;    int n;        piLen = N_PI * l;    twoBSq = 2.0 * b*b;    n=0;        x0 = 1.0/l;    box0 = b/x0;    fx0 = tan(piLen*x0) +     		sqrt(1.0+2.0*(box0*box0)) *     			tanh(piLen* sqrt(x0*x0 + twoBSq));        while(n<nm/2.0) {                x1 = x0/2.0 + (2.0*(n+1)-1.0)/(4.0*l);        box1 = b/x1;        fx1 = tan(piLen*x1) +         		sqrt(1.0+2.0*(box1*box1)) *         			tanh(piLen* sqrt(x1*x1 + twoBSq));                if (fx0*fx1<0) {            while((x0-x1)>0.00000000001) {                   x2 = (x0+x1)/2.0;                box2 = b/x2;                fx2 = tan(piLen*x2) +                 		sqrt(1.0+2.0*(box2*box2)) *                 			tanh(piLen* sqrt(x2*x2 + twoBSq));                                if (fx1*fx2<0.0) {                    x0 = x2;                    fx0 = fx2;                }                else {                    x1 = x2;                    fx1 = fx2;                }            }            zero[2*n] = x2;            n++;            x0 = (n+1.0)/l;            box0 = b/x0;            fx0  = tan(piLen*x0) +             		sqrt(1.0+2.0*(box0*box0)) *             			tanh(piLen* sqrt(x0*x0 + twoBSq));        }        else {            x0 = x1;            fx0 = fx1;        }    }    n=0;    x0 = 1.0/l;    box0 = b/x0;    fx0 = sqrt(1.0+2.0*(box0*box0)) *     		tan(piLen*x0) -     			tanh(piLen* sqrt(x0*x0 + twoBSq));        while(n<nm/2.0) {                x1 = x0/2.0 + (2.0*(n+1)+1.0)/(4.0*l);        box1 = b/x1;        fx1 = sqrt(1.0+2.0*(box1*box1)) *         		tan(piLen*x1) -         			tanh(piLen* sqrt(x1*x1 + twoBSq));                if (fx0*fx1<0) {            while((x1-x0)>0.00000000001) {                x2 = (x0+x1)/2.0;                box2 = b/x2;                fx2 = sqrt(1.0+2.0*(box2*box2)) *                 		tan(piLen*x2) -                 			tanh(piLen* sqrt(x2*x2 + twoBSq));                                if (fx0*fx2<0.0) {                    x1 = x2;                    fx1 = fx2;                }                else {                    x0 = x2;                    fx0 = fx2;                }            }            zero[1+2*n] = x2;            n++;            x0 = (n+1.0)/l;            box0 = b/x0;            fx0 = sqrt(1.0+2.0*(box0*box0)) *             		tan(piLen*x0) -             			tanh(piLen* sqrt(x0*x0 + twoBSq));        }        else {            x0 = x1;            fx0 = fx1;        }    }}int cde_reduit_nm (int nm, double *zero, double a, double b, double sPeriod){    int v;    v = 0;        while ((v < nm) &&           (N_TWOPI * zero[v] *            sqrt ((zero[v] * zero[v] + a) * b) < 0.5 / sPeriod))        v++;    if (v < nm-1) {        nm = v;        post ("WARNING, number of modes reduced to %ld.", (long)v);    }    return(nm);}void cde_mat_mod_calc(int nm, double b, double l, double s, double d,                      double *zero, double **mo, double *nor) // mo is a 2d matrix{    double x, y, zr;    int u,v;	// nor is x->s_temp[nmodes] and is already set to 0.0    for (v=0; v < nm; v++) nor[v] = 0.0;         for ( v=0; v < nm; v++ ) {    	zr = zero[v];        for ( u=0; u < nm; u++ ) {            y = N_PI * sqrt (zr * zr +2*b*b) * l;            x = 2 * y * ((u+1.0) / (nm+1.0) - 0.5);                        if ((v % 2) == 0) {                mo[v][u] = (exp(x-y) + exp(-x-y)) /                    (1.0 + exp(-2.0*y)) -                        cos (N_TWOPI * zr * l *                             ((u+1.0) / (nm+1) - 0.5) ) /                                 cos (N_PI * zr * l);            } else {                mo[v][u] =                     sin (N_TWOPI * zr * l *                         ((u+1.0) / (nm+1) - 0.5)) /                             sin (N_PI * zr *l) -                                 (exp (x-y) - exp (-x-y)) /                                     (1.0 - exp (-2.0*y));            }            nor[v] += mo[v][u] * mo[v][u];        }    }    for ( v=0; v < nm; v++ )        nor[v] = sqrt (nor[v] * d * s * l / (nm + 1.0));         for ( u=0; u < nm; u++ )        for ( v = 0; v < nm; v++ )            mo[v][u] /= nor[v];}// --------------------------------------------------------------------------------- // pc = largeur de bande en freq, imprime' directement dans le fichier d'analyse // pf = coefficient de pertes proportionnelles au carre de la pulsation du mode. // Pour avoir le meme ordre de grandeur avec le premier parametre, on multiplie//   ce facteur par: pow (2pi*1000,2,0), sorte de normalisation a 1000Hz.    void string_freq_loss_calc(int nm, double *zo, double *fre, double *abs, 									double a, double b, double pc, double pf){    int i;    double z, f, lo;        for (i=0; i < nm; i++) {    	z = zo[i];    	    	f = N_TWOPI * z * sqrt ((z*z + a) * b);    	lo = pc + f * f * pf * 1e-6;    	        fre[i] = f;        abs[i] = lo;    }}        // ---------------------------------------------------------------------------------                  // functions for pitch adjustment:double get_zero_corde (double l, double beta){	double x0,fx0,x1,fx1,x2,fx2;	double box0, box1, box2;	double zero = 0;	double piLen, twoBSq;	int j,got_zero;  	j=0;	got_zero=0;		piLen = N_PI * l;	twoBSq = 2.0 * beta*beta;		x0 = 1.0/l;	box0 = beta/x0;	fx0 = tan(piLen*x0)+			sqrt(1.0+2.0*(box0*box0))*				tanh(piLen * sqrt(x0*x0 + twoBSq));	while(!got_zero && j++ < 1000)  {		x1 = x0/2.0 + (1.0)/(4.0*l);		box1 = beta/x1;		fx1 = tan(piLen*x1)+sqrt(1.0+2.0*(box1*box1))*				tanh(piLen* sqrt(x1*x1 + twoBSq));		if (fx0*fx1<0) {			x2 = x0;			while((x0-x1)>1.0e-11)  {				x2 = (x0+x1)/2.0;				box2 = beta/x2;				fx2 = tan(piLen*x2)+						sqrt(1.0+2.0*(box2*box2))*							tanh(piLen* sqrt(x2*x2 + twoBSq));              				if (fx1*fx2<0.0)  {					x0 = x2;					fx0 = fx2;				}				else  {					x1 = x2;					fx1 = fx2;				}			}			zero = x2;			got_zero = 1;		}		else  {			x0 = x1;			fx0 = fx1;		}	}	if (!got_zero) 		zero = 1.0/(2.0*l);	return (zero);}    double adjust_string_length (double freq_goal, double lg, double te,                            double de, double se, double me, double rg){	double l0,l1,l2,freq0,freq1,freq2,zero,a,b,beta;	double piRg;	piRg = N_PI * rg;		beta = sqrt(te/(8.0*(piRg*piRg)*me*se));	a = 2.0*beta*beta;	b = me*rg*rg/de;  	l0 = lg;	zero = get_zero_corde(l0,beta);	freq0 = N_TWOPI*zero* sqrt((zero*zero + a)*b);  	if(freq0 > freq_goal) {		// post("ERROR.. lengh greater than %em.\n",lg);		while (freq0 > freq_goal) {			l0=2.0*l0;			zero  = get_zero_corde(l0,beta);			freq0 = N_TWOPI*zero* sqrt((zero*zero + a)*b);		}		l1 = 0.5*l0;		zero  = get_zero_corde(l1,beta);		freq1 = N_TWOPI*zero* sqrt((zero*zero + a)*b);      		l2 = l1;      		while(fabs(freq1-freq0)>1.0e-5) {			l2 = (l1+l0)/2.0;			zero  = get_zero_corde(l2,beta);			freq2 = N_TWOPI*(zero)* sqrt((zero*zero + a)*b);          			if (freq2 > freq_goal) {				l1 = l2;				freq1 = freq2;			}			else {				l0 = l2;				freq0 = freq2;			}		}	}  	else {    	// post("ERROR.. lengh smaller than %em.\n",lg);		while (freq0 < freq_goal) {			l0=0.5*l0;			zero  = get_zero_corde(l0,beta);			freq0 = N_TWOPI*(zero)* sqrt((zero*zero + a)*b);		}		l1 = 2.0*l0;		zero  = get_zero_corde(l1,beta);		freq1 = N_TWOPI*(zero)* sqrt((zero*zero + a)*b);      		l2 = l1;      		while(fabs(freq1-freq0)>1.0e-5) {			l2 = (l1+l0)/2.0;			zero  = get_zero_corde(l2,beta);			freq2 = N_TWOPI*zero*sqrt((zero*zero + a)*b);          			if (freq2 < freq_goal) {				l1 = l2;				freq1 = freq2;			}			else {				l0 = l2;				freq0 = freq2;			}		}	}	return (l2);  }double adjust_string_tension (double freq_goal, double lg, double te,                             double de, double se, double me, double rg){  double t0,t1,t2,beta0,beta1,beta2,freq0,freq1,freq2,zero,  a0,b,a1,a2,te_limit,freq_limit,a_limit,beta_limit;    double piRg, piRgSqMeSe;    b = me*rg*rg/de;    piRg = N_PI * rg;  piRgSqMeSe = (8.0* piRg*piRg *me*se);    t0 = te;  beta0 = sqrt(t0/piRgSqMeSe);   a0 = 2.0*beta0*beta0;  zero = get_zero_corde(lg,beta0);  freq0 = N_TWOPI*zero* sqrt((zero*zero + a0)*b);    if(freq0 < freq_goal)    {      /*fprintf(stderr,"..tension greater than %e N.\n",te);*/            while (freq0 < freq_goal)        {          t0=2.0*t0;          beta0 = sqrt(t0/piRgSqMeSe);           a0 = 2.0*beta0*beta0;          zero = get_zero_corde(lg,beta0);          freq0 = N_TWOPI*zero* sqrt((zero*zero + a0)*b);        }      t1 = 0.5*t0;      beta1 = sqrt(t1/piRgSqMeSe);       a1 = 2.0*beta1*beta1;      zero = get_zero_corde(lg,beta1);      freq1 = N_TWOPI*zero* sqrt((zero*zero + a1)*b);            t2 = t1;            while(fabs(freq1-freq0)>1.0e-5)        {          t2 = (t1+t0)/2.0;          beta2 = sqrt(t2/piRgSqMeSe);           a2 = 2.0*beta2*beta2;          zero = get_zero_corde(lg,beta2);          freq2 = N_TWOPI*zero* sqrt((zero*zero + a2)*b);                    if (freq2 < freq_goal)            {              t1 = t2;              freq1 = freq2;            }          else                {              t0 = t2;              freq0 = freq2;            }        }    }    else     {      /*fprintf(stderr,"..tension smaller than %e N.\n",te);*/      te_limit = 0.0;      beta_limit = sqrt(te_limit/piRgSqMeSe);       a_limit = 2.0*beta_limit*beta_limit;      zero = get_zero_corde(lg,beta_limit);      freq_limit = N_TWOPI*zero*sqrt((zero*zero + a_limit)*b);            if (freq_limit>freq_goal)        {            // "Zero tension and %1.2e young-modulus produces %1.2eHz\n",            // me, freq_limit            // "With zero tension young-modulus should be smaller than %1.2e",            // adjust_young_corde (freq_goal,lg,0.0,de,se,me,rg,pf,pc));            post ("E_ERROR_ADJUSTING_PITCH",0);            return (te);        }                  while (freq0 > freq_goal)        {          t0=0.5*t0;          beta0 = sqrt(t0/piRgSqMeSe);           a0 = 2.0*beta0*beta0;          zero = get_zero_corde(lg,beta0);          freq0 = N_TWOPI*zero* sqrt((zero*zero + a0)*b);         }      t1 = 2.0*t0;      beta1 = sqrt(t1/piRgSqMeSe);       a1 = 2.0*beta1*beta1;      zero = get_zero_corde(lg,beta1);      freq1 = N_TWOPI*zero* sqrt((zero*zero + a1)*b);            t2 = t1;            while(fabs(freq1-freq0)>1.0e-5)        {          t2 = (t1+t0)/2.0;          beta2 = sqrt(t2/piRgSqMeSe);           a2 = 2.0*beta2*beta2;          zero = get_zero_corde(lg,beta2);          freq2 = N_TWOPI*zero* sqrt((zero*zero + a2)*b);                    if (freq2 > freq_goal)            {              t1 = t2;              freq1 = freq2;            }          else                {              t0 = t2;              freq0 = freq2;            }        }    }  return (t2);  }double adjust_string_young (double freq_goal, double lg, double te, double de,                           double se, double me, double rg){  double me0,me1,me2,beta0,beta1,beta2,freq0,freq1,freq2,zero,  a0,b0,b1,b2,a1,a2,freq_limit,a_limit,beta_limit,b_limit,me_limit;    	double piRg, piRgSqSe, rgSqoDe;  	piRg = N_PI * rg;	piRgSqSe = (8.0* piRg*piRg * se);  	rgSqoDe = rg*rg/de;  	  me0 = me;  beta0 = sqrt(te/(piRgSqSe*me0));   a0 = 2.0*beta0*beta0;  b0 = me0*rgSqoDe;  zero = get_zero_corde(lg,beta0);  freq0 = N_TWOPI*zero* sqrt((zero*zero + a0)*b0);    if(freq0 < freq_goal)    {      /*fprintf(stderr,"..young modulus greater than %e N/m2.\n",me);*/            while (freq0 < freq_goal)        {          me0=2.0*me0;          beta0 = sqrt(te/(piRgSqSe*me0));           a0 = 2.0*beta0*beta0;          b0 = me0*rgSqoDe;          zero = get_zero_corde(lg,beta0);          freq0 = N_TWOPI*zero* sqrt((zero*zero + a0)*b0);        }      me1 = 0.5*me0;      beta1 = sqrt(te/(piRgSqSe*me1));       a1 = 2.0*beta1*beta1;      b1 = me1*rgSqoDe;      zero = get_zero_corde(lg,beta1);      freq1 = N_TWOPI*zero* sqrt((zero*zero + a1)*b1);            me2 = me0;            while(fabs(freq1-freq0)>1.0e-5)        {          me2 = (me1+me0)/2.0;          beta2 = sqrt(te/(piRgSqSe*me2));           a2 = 2.0*beta2*beta2;          b2 = me2*rgSqoDe;          zero = get_zero_corde(lg,beta2);          freq2 = N_TWOPI*zero* sqrt((zero*zero + a2)*b2);                    if (freq2 < freq_goal)            {              me1 = me2;              freq1 = freq2;            }          else                {              me0 = me2;              freq0 = freq2;            }        }    }    else     { /*     fprintf(stderr,".. young modulus smaller than %e N/m2\n",me);*/      me_limit = 1.0e-20;      beta_limit = sqrt(te/(piRgSqSe*me_limit));       a_limit = 2.0*beta_limit*beta_limit;      b_limit = me_limit*rgSqoDe;            zero = get_zero_corde(lg,beta_limit);      freq_limit = N_TWOPI*zero* sqrt((zero*zero + a_limit)*b_limit);            if (freq_limit>freq_goal)        {            // "%e young modulus produces %fHz\n",me_limit,freq_limit);            // fprintf(stderr,"With %1.2e young-modulus, tension should be smaller than %1.2e\n",me_limit,            // adjust_tension_corde (freq_goal,lg,te,de,se,1.0e-10,rg,pf,pc));                        post ("E_ERROR_ADJUSTING_PITCH",0);            return (me);        }            while (freq0 > freq_goal)        {          me0=0.5*me0;          beta0 = sqrt(te/(piRgSqSe*me0));           a0 = 2.0*beta0*beta0;          b0 = me0*rgSqoDe;          zero = get_zero_corde(lg,beta0);          freq0 = N_TWOPI*zero* sqrt((zero*zero + a0)*b0);         }      me1 = 2.0*me0;      beta1 = sqrt(te/(piRgSqSe*me1));       a1 = 2.0*beta1*beta1;      b1 = me1*rgSqoDe;      zero = get_zero_corde(lg,beta1);      freq1 = N_TWOPI*zero* sqrt((zero*zero + a1)*b1);            me2 = me0;            while(fabs(freq1-freq0)>1.0e-5)        {          me2 = (me1+me0)/2.0;          beta2 = sqrt(te/(piRgSqSe*me2));           a2 = 2.0*beta2*beta2;          b2 = me2*rgSqoDe;          zero = get_zero_corde(lg,beta2);          freq2 = N_TWOPI*zero* sqrt((zero*zero + a2)*b2);                    if (freq2 > freq_goal)            {              me1 = me2;              freq1 = freq2;            }          else                {              me0 = me2;              freq0 = freq2;            }        }    }  return (me2);  }double adjust_string_density (double freq_goal, double lg, double te,                             double de, double se, double me, double rg){  double de0,de1,de2,b0,b1,b2,freq0,freq1,freq2,zero,a,beta;  double piRg, meRgSq;    piRg = N_PI * rg;  meRgSq = me*rg*rg;    beta = sqrt(te/(8.0*piRg*piRg*me*se));  a = 2.0*beta*beta;  zero = get_zero_corde(lg,beta);    de0 = de;  b0 = meRgSq/de0;  freq0 = N_TWOPI*zero*sqrt((zero*zero + a)*b0);    if(freq0 > freq_goal)    {/*      fprintf(stderr,".. density greater than %ekg/m3.\n",de);*/      while (freq0 > freq_goal)        {          de0=2.0*de0;          b0 = meRgSq/de0;          freq0 = N_TWOPI*zero* sqrt((zero*zero + a)*b0);        }      de1 = 0.5*de0;      b1 = meRgSq/de1;      freq1 = N_TWOPI*zero*sqrt((zero*zero + a)*b1);            de2 = de1;            while(fabs(freq1-freq0)>1.0e-5)        {          de2 = (de1+de0)/2.0;          b2 = meRgSq/de2;          freq2 = N_TWOPI*zero*sqrt((zero*zero + a)*b2);          if (freq2 > freq_goal)            {              de1 = de2;              freq1 = freq2;            }          else                {              de0 = de2;              freq0 = freq2;            }        }    }    else     {  /*    fprintf(stderr,".. density smaller than %ekg/m3.\n",de);*/      while (freq0 < freq_goal)        {          de0=0.5*de0;          b0 = meRgSq/de0;          freq0 = N_TWOPI*zero* sqrt((zero*zero + a)*b0);        }      de1 = 2.0*de0;      b1 = meRgSq/de1;      freq1 = N_TWOPI*zero*sqrt((zero*zero + a)*b1);       de2 = de1;            while(fabs(freq1-freq0)>1.0e-5)        {                    de2 = (de1+de0)/2.0;          b2 = meRgSq/de2;          freq2 = N_TWOPI*zero*sqrt((zero*zero + a)*b2);          if (freq2 < freq_goal)            {              de1 = de2;              freq1 = freq2;            }          else                {              de0 = de2;              freq0 = freq2;            }        }    }  return (de2);  }